---
title: Java经典算法之冒泡排序
categories: 技术笔记
tags:
  - Java
  - 冒泡排序
  - 冒泡排序的理解
excerpt: 比较两个相邻的元素，将值大的元素交换至右端。
cover: >-
  https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg@master/img5c30665ce0b87-20200918145746650.png
articleLink: f64fae17be681905
date: 2019-01-05 16:13:19
---


原理：比较两个相邻的元素，将值大的元素交换至右端。

思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。

第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；

第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；

依次类推，每一趟比较次数-1；

……

![Java经典算法之冒泡排序](https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg@master/img5c30665ce0b87-20200918145746650.png "Java经典算法之冒泡排序")

由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

代码实现：

```
/*冒泡排序*/
package maopao;

import java.util.Arrays;

public class maopao {

	public static void main(String[] args) {
		//定义个静态数组
	   int[] n  = {41,72,93,456,12};
	   //循环 控制比较轮数
	   //减1是因为 最后一个最大数不循环了 不比较了
	   for(int i=0;i<n.length-1;i++) {  
		   //相邻的进行比较
		   //减i 是减去已经排好的！ 不再进行排 
		   for(int j=0;j<n.length-1-i;j++) {
			   //< 从大到小排序
			   //> 从小到大排序
			   if(n[j]>n[j+1]) {
				   //定 中间变量进行交换位置！
				   int tem = n[j];
				   n[j]=n[j+1];
				   n[j+1]=tem;
				   
			   }
		   }
	   }
	   //输出为 字符串类型！ api
	   	System.out.println(Arrays.toString(n));

	}
}
```


